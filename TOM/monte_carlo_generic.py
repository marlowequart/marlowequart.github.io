'''
This script looks at a trading strategy over a given period and generates the 
expected return, and runs the monte carlo simulation to determine a potential range
of outcomes

The purpose is to see if a given strategy has a high likelihood of catastrophic failure,
and also what the expected returns are for this strategy


Output: returns over period and plot of equity


Notes:


pandas version: 0.18.1
matplotlib version: 3.0.3
mpl_finance version: 0.10.0
numpy version: 1.10.1
scipy version: 0.16.0

python version: 3.5.4

'''

import pandas as pd
import os
import numpy as np
import re
import datetime
import matplotlib.pyplot as plt
import matplotlib.ticker as plticker
import time





def main():
	start_time = time.time()
	
	
	
	#####
	# Monte Carlo Sim
	#####
	num_simulations = 100
	# input the number of trades to run test over
	num_trades = 250
	
	
	# Equity curve with stop loss, and Kelly position sizing
	# Optimum strategy seems to be around 5x leverage $/point and 1/2 Kelly
	# I will want to run this strategy through some more monte carlo type testing
	# set stop loss to 3% drop
	stop_loss=3
	start_equity=100000
	# leverage factor is $ per point
	levg_fact=5
	
	
	# kelly_fraction is the fraction of full kelly to use for smoother returns
	kelly_fraction=0.75
	
	# input starting ratios for calculating kelly position sizing
	num_wins=245
	num_loss=135
	win_prob=num_wins/(num_wins+num_loss)
	loss_prob=1.-win_prob
	# payoff calculated by avg profit/stop loss
	avg_win=1.75
	payoff=avg_win/stop_loss
	# The Kelly formula is kelly_fraction*(payoff*win_prob-loss_prob)/payoff
	
	# Here is the info on the distribution of gains for the trades to be used to
	# generate the returns for each month:
	# These values are generated in the stop_analysis.py script
	
	# using extended data:
	# ~ returns_avg=0.48
	# ~ returns_std=2.07
	
	# using recent data:
	returns_avg=0.53
	returns_std=2.23
	
	# Input starting price of market and data on avg returns over given time frame
	mrkt_start=2800
	mrkt_avg=0.9
	mrkt_std=4.35
	
	
	# This function will generate an equity curve for each simulation
	# The output will be a dataframe with each row being the equity curve for that simulation
	# We can then run statistics on the results of all of the equity curves generated by this function
	
	all_equity_curves=[]
	for i in range(num_simulations):
		#
		# when starting each new simulation, create a new historical results profile using the input profile
		# from above. This will be changed as the simulation progresses
		# ~ hist_results=hist_results_input
		equity_curve=[start_equity]
		market_val=[mrkt_start]
		# ~ print()
		# ~ print(i)
		# run a new simulation over the total number of months
		# this simulation will not include updating kelly ratios each time for improved speed
		for y in range(num_trades):
			#Set percentage of equity to bet for this month
			kelly=kelly_fraction*equity_curve[y]*(payoff*win_prob-loss_prob)/payoff
			# bet_size = the factor to multiply by the absolute win
			# (i.e. this represents the number of contracts. Using fractional contracts)
			# normalizing to the monthly open price of 1
			bet_size=kelly/(levg_fact*market_val[y]*(stop_loss/100))
			
			# generate this trades % return
			cur_rtn=round(np.random.normal(returns_avg, returns_std),3)
			abs_rtn=market_val[y]*cur_rtn/100
			# ~ print('cur_rtn: '+str(cur_rtn))
			# hits stop loss?
			if cur_rtn<-stop_loss:
				equity_curve.append(equity_curve[y]-levg_fact*stop_loss/100*market_val[y])
			else:
				equity_curve.append(equity_curve[y]+bet_size*levg_fact*abs_rtn)
			# ~ print(equity_curve)
			
			#generate this months stock market return
			cur_stock_rtn=round(np.random.normal(mrkt_avg, mrkt_std),3)
			cur_delta=market_val[y]*cur_stock_rtn/100
			market_val.append(market_val[y]+cur_delta)
			
		
		# ~ print(equity_curve)
		# add resultant equity curve to the dataframe
		all_equity_curves.append(equity_curve)
		
	
	# ~ print(all_equity_curves)
	results_df=pd.DataFrame(all_equity_curves)
	
	# Generate stats
	num_col=num_trades
	losing_sim=0
	cagr=[]
	for index, row in results_df.iterrows():
		# Probability of loss, check last column on each row
		if row[num_col] < start_equity:
			losing_sim += 1
		
		# CAGR of each sim (ignore losing sims)
		# ~ print(type(row[num_col].item()))
		# ~ print(type(1/(num_trades/12)))
		cagr_sim=100*((row[num_col]/start_equity)**(1/(num_trades/12))-1)
		if cagr_sim > 0:
			cagr.append(cagr_sim)
	
	print()
	print('Probability of ruin: '+str(round(100*losing_sim/num_simulations,1)))
	
	print('Mean CAGR of winning sims: '+str(round(np.mean(cagr),1))+', std dev: '+str(round(np.std(cagr),2)))
	
	
	print()
	print('%f seconds to run script' % (time.time() - start_time))
	print()
	
	return
	
	
	
	
	# Plot returns over dates
	fig = plt.figure()
	ax = plt.subplot()
	
	# ~ ax.plot(dates,basic_equity,color='b',label='Basic Equity')
	# ~ ax.plot(dates,stopped_equity,color='c',label='Equity with Stop Losses')
	ax.plot(dates,kelly_equity,color='r',label='Equity using Kelly')
	
	ax.set_ylabel('Equity')
	ax.set_xlabel('Date')
	
	
	ax.grid()
	plt.legend()
	plt.show()
	
	
	return

main()
