####################################################################################################
"""
MS_USA13030-X1_Cont.py
Steve Wood 2018-0-07

Mixed-signal Simulation of BLDC motor
MCU emulation in Python
Analog circuit simulation in NGspice
PySpice ties the two together for true mixed-signal simulation, which is not possible in LTspice.

Schematic captured in LTspice to generate NGspice netlist. 
KiCAD schematic capture could also be used to generate the NGspice netlist.
 
Slight manual modification of LTspice netlist needed as follows (can be automated later):
Add top level subcircuit wrapper. I don't know how to pass top level subcircuit parameters from Python to NGspice, so the top level must be free of any parameters.
Delete .backanno statement automatically generated by LTspice (ignored anyway, not a problem)
Delete .lib statements are (ignored, anyway, not a problem; all library include statements need to be in Python)
Parameters separated by spaces must be included (manually) on each .subckt line.  No " params:" used here (as on instantiation line).
Change any unicode to ascii (such as "mu" to "u" for micro).

PySPICE NGspice Parser compatibility requirements to be met at the LTspice schematic capture level (not comprehensive for all circuits, but only issues found for this particular circuit):
* No utf-8 "mu" for micro allowed.  Must use simple 'u'.
* No spaces allowed in equations
* No IF statements (they exist in NGspice, but the format is different)
* No "limit" function. Use min(max(,),) instead.
* No .param statements; parameters must be passed at the instance callout only.
* No .ic statements ; initial conditions can only exist at the instance callout
* No SGN function.  Check NGspice manual for other functions that differ from LTspice
* Only independent sources can be referenced for currents used in expressions (no i(L4) allowed for example; instead insert a 0V source and read the current through it).
* Do not rely on case to differentiate labels.  Netlist is converted to all lower case by PySPICE.
* Need to prepend "dc x " (where 'x' is the initial value, usually zero) manually for all sources that do not have an explicit DC value (PWL, PULSE, etc), otherwise NGspice will warn that the time 0 value is being used for the DC solution (benign warning, but best to clean it up).
* Inductors and capacitors need to have their parasitics shown explicitly, not built into the component
* No dashes allowed in file names

"""

####################################################################################################
import math
import pickle
import matplotlib.pyplot as plt
####################################################################################################
import PySpice.Logging.Logging as Logging
logger = Logging.setup_logging()


from PySpice.Probe.Plot import plot
from PySpice.Spice.Netlist import Circuit
from PySpice.Spice.NgSpice.Shared import NgSpiceShared
from PySpice.Unit import *
from PySpice.Spice.Library import SpiceLibrary

from PySpice.Doc.ExampleTools import find_libraries
####################################################################################################
import datetime
sim_start_time = datetime.datetime.now()
print()
print('Simulation Start Time =', sim_start_time)
print()
####################################################################################################
# NgSpiceShared.LIBRARY_PATH = '/home/steve/.local_NGspiceForPySpice/lib/libngspice{}.so'
class MyNgSpiceShared(NgSpiceShared):

    ##############################################

    def __init__(self, g_ovr_i, g_angle, gear_rat, deg_range, i_lim, pz_cap, pz_rbig, pz_rsmall, vdd_hall, **kwargs):

        super().__init__(**kwargs)
# Section below needed only to prevent harmless "AttributeError: 'MyNgSpiceShared' object has no attribute 'clk_out'" messages at beginning of run
        self.clk_out = 0 
        self.angle_out = 0
        self.target_out = 2.5
        self.w_out = 0
        self.h1_out = 0
        self.h2_out = 0
        self.h3_out = 0
        self.i_sns_a_out = 0
        self.i_sns_b_out = 0
        self.i_sns_c_out = 0
        self.p_28v_out = 28
        self.va_val = 0
        self.vb_val = 0
        self.vc_val = 0
# Section below actually needed for initialization.
        self.clk_out_old = 0
        self.oldtrap1 = 0.0
        self.oldtrap2 = 0.0
        self.oldtrap3 = 0.0 
        self.delta_v = 10E3/62.5E3 # slew rate over sample freq 
        self.slewrate = 10E3 
        self.i_c_old = 0.0
        self.v_c_old = 0.0
        self.inz2 = 0.0 
        self.inz1 = 0.0
        self.midz2 = 0.0
        self.midz1 = 0.0
        self.outz2 = 0.0
        self.outz1 = 0.0
        self.time_filt = 0.0
        self.dig_timestep = 16.0E-6
        self.drv_dir = 1
        self.angle_out_old = 0
        self.h1_old = 0
        self.h2_old = 0
        self.h3_old = 0
        self.i_pol = 1
        self.i_pol_old = 1
        self.i_pol_smooth = 1
        self.outz1_cnt = 0
        self.i_cmpst = 0
        self.i_pol2B = 0
        self.i_pol2B_old = 0
        self.hx_time_old = 0
        self.ana_time_old = 0.0
    ##############################################

    def get_vsrc_data(self, voltage, time, node, ngspice_id):
        self._logger.debug('ngspice_id-{} get_vsrc_data @{} node {}'.format(ngspice_id, time, node))
        
        timestep = time - self.ana_time_old # Debugging aid shows timestep deltas (not just time stamps) when non-zero, and in RED when negative
        if timestep > 0:
            print('Timestep = ', time - self.ana_time_old)
        if timestep < 0:
            print('\033[1;31mTimestep = ', time - self.ana_time_old, '\033[1;31m  ************************************************************************************************************************') 
        self.ana_time_old = time # END debugging aid
                
        if (round(self.clk_out) != round(self.clk_out_old)) and (time != self.time_filt): #This "if" statement evaluated once for each node for each NgSpice timestep; for speed, the calculations following this conditional are only executed once per dig_timestep.
            self.time_filt = time #Need time stamp to avoid executing this code redundantly
            self.clk_out_old = self.clk_out #Need state of clk to know when it next changes
            pot_bip = self.angle_out*2.5/(gear_rat*deg_range/360*2*math.pi) #Bipolar potentionmeter output based angle output from motor
            direction = int(math.copysign(0.5,self.angle_out - self.angle_out_old) + 0.5) #direction; updated once per dig_timestep, so not unrealistic (not instantaneous)
            dir_bip = 2*direction-1 #bipolar version of boolean 'direction'
            self.angle_out_old = self.angle_out #Remember angle to get direction at next dig_timestep
            trgt_bip = self.target_out-2.5 #Remove DC bias from target control signal (0 to 5V)
            duty_raw = g_angle*(pot_bip-trgt_bip) #Raw duty cycle is simply gain times actual minus target angle.
            duty = min(abs(duty_raw),1) #Clip raw duty to get duty           
            dir_goal = int(math.copysign(0.5, duty_raw) + 0.5)  # direction goal; boolean
            dir_goal_bip = 2*dir_goal-1 # direction goal; bipolar
            i_a = (self.i_sns_a_out-2.5)/2.5 #Remove  offset and normalize phase 'A' current sensor
            i_b = (self.i_sns_b_out-2.5)/2.5
            i_c = (self.i_sns_c_out-2.5)/2.5
            self.i_cmpst = max(abs(i_a), abs(i_b), abs(i_c)) #Composite normalized current of all three phases; unsigned           

            #Pole-zero compensation of current-limit loop ( zero to cancel L/R pole, the electrical time-constant of the motor)
            ovr_i_raw = (1 + g_ovr_i * (i_lim - self.i_cmpst)) * self.i_pol_smooth #Raw over-current signal
            v_c = min(max(0,self.i_c_old*self.dig_timestep/pz_cap + self.v_c_old), 1) #Voltage across cap in pole-zero comp of current-limit loop; clamping here ensures no sign
            self.i_c_old = (ovr_i_raw - v_c)/(pz_rbig + pz_rsmall) #Current through cap to be remembered
            self.v_c_old = v_c #Voltage across cap to be remembered
            ovr_i_pz = min(max(0,v_c + pz_rsmall * self.i_c_old),1) #Over-current pole-zero output; clamped; any value less than 1 indicates current limit 
            
            ################################################################
            """ 
            Elliptic filter below for current limit loop to supress the 18.3kHz (min) resonance of the first LC in the output filter.
            See Elliptic_62k5Hz_4th_500mdB_15kHz.py for details.  Topology is Direct Form 1.
            """
            b10 = 0.1795978
            b11 = 0.25263921
            b12 = 0.1795978
            a10 = 1.
            a11 = -0.39029624
            a12 = 0.25226106
            b20 = 1.
            b21 = 0.35147428
            b22 = 1.
            a20 = 1.
            a21 =-0.06669631
            a22 = 0.83470697
    
            mid_filt = ovr_i_pz*b10 + self.inz1*b11 + self.inz2*b12 - self.midz1*a11 - self.midz2*a12
            out_filt = mid_filt*b20 + self.midz1*b21 + self.midz2*b22 - self.outz1*a21 - self.outz2*a22
            self.inz2 = self.inz1  
            self.inz1 = ovr_i_pz
            self.midz2 = self.midz1
            self.midz1 = mid_filt
            self.outz2 = self.outz1
            self.outz1 = out_filt
            ########################### END of elliptic filter##############    
    
            duty = min(self.outz1, duty)   # cannot use out_filt here (it's not remembered)
            if self.i_pol == -1:
                d_scaled = self.outz1 # no feed forward needed for reverse current regulation; better to use full bus voltage (not 22V max). Also need to override positional loop (use self.outz1 instead of duty here); active high instead of just open-drain output for outz1 when regulating reverse current.
            else:
                d_scaled = min(max(0, duty*22/self.p_28v_out), 1) # feed-forward of Vbus
                 
            # Determine the polarity of the 3-phase current            
            hx_edge_flag = False # This flag needed to limit execution of "Decide" code below           
            if round(self.h1_out/vdd_hall) > round(self.h1_old/vdd_hall): # If h1 has a rising edge:
                hx_edge_flag = True
                if direction:
                    self.i_pol2B = math.copysign(1,i_c)  # polarity of current determined according to which hx edge and direction of rotation
                else:
                    self.i_pol2B = math.copysign(1,i_a)
            elif round(self.h2_out/vdd_hall) > round(self.h2_old/vdd_hall):
                hx_edge_flag = True                
                if direction:
                    self.i_pol2B = math.copysign(1,i_a)
                else:
                    self.i_pol2B = math.copysign(1,i_b)                
            elif round(self.h3_out/vdd_hall) > round(self.h3_old/vdd_hall):
                hx_edge_flag = True                
                if direction:
                    self.i_pol2B = math.copysign(1,i_b)
                else:
                    self.i_pol2B = math.copysign(1,i_c)
            DTIME_THRESH = 3E-3 # Time interval threshold to determine if motor was turning  fast enough to make negative current test valid; this can be calculated from motor parameters - empirical for now.
            if hx_edge_flag and self.i_pol2B == self.i_pol2B_old and time - self.hx_edge_time_old < DTIME_THRESH: # Require two consecutive polarity readings to match while running fast to prevent oscillation
                self.i_pol = self.i_pol2B
                #~ print('self.hx_edge_time_old = ', self.hx_edge_time_old)
            if hx_edge_flag:
                self.i_pol2B_old = self.i_pol2B
                self.hx_edge_time_old = time
                
            self.h1_old = self.h1_out # Need to remember the previous state of h1 to find rising edges
            self.h2_old = self.h2_out
            self.h3_old = self.h3_out
            
            # Decide what to do based on current polarity determined above
            I_CMPST_THRESH_LO = i_lim * 0.5
            if hx_edge_flag:
                if self.i_cmpst < I_CMPST_THRESH_LO and self.i_pol_old == 1:
                    self.i_pol = 1 # Reverse decision made earlier if i_cmpst was too low (noise filter); favor keeping i_pol = 1 (driving motor in desired direction)
               
            OUTZ1_CNT_STOP = 32
            OUTZ1_SETTLE_THRESH = 1E-4
            if abs(self.outz1) < OUTZ1_SETTLE_THRESH: # Count how long the current-limit elliptic filter output has been settled.  Needs to be well-settled for changing i_pol
                self.outz1_cnt = self.outz1_cnt + 1
            else:
                self.outz1_cnt = 0
                
            I_MIN = 100E-3 # min current above which we consider that all is well (must allow for tolerance of Hall effect sensor)     
            if self.outz1_cnt > OUTZ1_CNT_STOP and self.i_pol == -1 or self.i_cmpst < I_MIN: # if reverse current limit has completely settled to a non-limiting state OR there's little current flow, then reset to make sure that the drive direction is in line with the position goal.  
                self.i_pol = 1
                self.outz1_cnt = 0
             
            I_CMPST_THRESH_HI = i_lim * 1.1
            if self.outz1_cnt > OUTZ1_CNT_STOP and self.i_pol == 1 and self.i_cmpst > I_CMPST_THRESH_HI: # This condition can catch entry into regen when the reversal happens too quickly for checking i_cmpst polarity.
                self.i_pol = -1
                self.outz1_cnt = 0
                   
            if self.i_pol == 1: # If i_pol is positive, this indicates normal operation (no regen current)
                drv_dir_dig = dir_goal_bip
            else:
                drv_dir_dig = dir_bip # If i_pol is negative, then regeneration is occuring, so set the driven direction to match the actual direction of rotation 
            self.i_pol_old = self.i_pol
                
            delta_v = self.delta_v                
            if self.i_pol_smooth != self.i_pol: # if different, then update; i_pol_smooth used in elliptic filter to reduce filter ringing (causes voltage spikes)
                self.i_pol_smooth = self.i_pol_smooth + delta_v*math.copysign(1,self.i_pol - self.i_pol_smooth) # increment/decrement by delta_v
                self.i_pol_smooth = min(max(-1,self.i_pol_smooth),1) 
    
            trapdig1 = round(self.h1_out/vdd_hall)-0.5 # raw square waves (not trapezoidal yet)
            trapdig2 = round(self.h2_out/vdd_hall)-0.5
            trapdig3 = round(self.h3_out/vdd_hall)-0.5

            if self.drv_dir != drv_dir_dig: # if different, then update; smooting prevents excessive voltage spikes
                self.drv_dir = self.drv_dir + delta_v*math.copysign(1,drv_dir_dig - self.drv_dir) # increment/decrement by delta_v
                self.drv_dir = min(max(-1,self.drv_dir),1)
            if self.oldtrap1 == trapdig1: # if no difference beween square and trapezoidal signal, then delta v needs to be 0
                delta_v1 = 0
            else:
                delta_v1 = delta_v*math.copysign(1,trapdig1-self.oldtrap1) # assign sign to delta v for each trapezoidal wave
            if self.oldtrap2 == trapdig2:
                delta_v2 = 0
            else:
                delta_v2 = delta_v*math.copysign(1,trapdig2-self.oldtrap2)
            if self.oldtrap3 == trapdig3:
                delta_v3 = 0
            else:
                delta_v3 = delta_v*math.copysign(1,trapdig3-self.oldtrap3)
            trap1 = self.oldtrap1 + delta_v1 # Update trap1 by delta v
            trap2 = self.oldtrap2 + delta_v2        
            trap3 = self.oldtrap3 + delta_v3
            trap1 = min(max(-abs(trapdig1),trap1),abs(trapdig1)) # clip trap at extremes allowed (adding delta v above may exceed the limits)
            trap2 = min(max(-abs(trapdig2),trap2),abs(trapdig2))
            trap3 = min(max(-abs(trapdig1),trap3),abs(trapdig3))
            self.oldtrap1 = trap1 # store trap value for comparison at next SPICE timestep
            self.oldtrap2 = trap2
            self.oldtrap3 = trap3       
            trilvl_a = self.drv_dir*(trap1-trap2) # Build trapezoidal waveforms to drive motor phases
            trilvl_b = self.drv_dir*(trap2-trap3)
            trilvl_c = self.drv_dir*(trap3-trap1)
            self.va_val=d_scaled/2.0*(1+trilvl_a)*self.p_28v_out # Scale trapezoidal waveforms (replaced by PWM in real code)
            self.vb_val=d_scaled/2.0*(1+trilvl_b)*self.p_28v_out           
            self.vc_val=d_scaled/2.0*(1+trilvl_c)*self.p_28v_out
         
        ################### Outputs below go from Python to NGspice ####################################################            
        if node == 'va':
            voltage[0]=self.va_val
        elif node == 'vb':
            voltage[0]=self.vb_val          
        elif node == 'vc':
            voltage[0]=self.vc_val
        # Dummy outputs below are just for probing.  They are no-connects in NGspice    
        elif node == 'vi_limit': # this can be used to probe various "nets" inside the Python (not NGspice)
            voltage[0]=self.outz1 #output of elliptic filter
        elif node == 'vdrv_dir': # this can be used to probe various "nets" inside the Python (not NGspice)
            voltage[0]=self.drv_dir 
        elif node == 'vi_pol': # this can be used to probe various "nets" inside the Python (not NGspice)
            voltage[0]=self.i_pol_smooth 
        elif node == 'vi_cmpst': # this can be used to probe various "nets" inside the Python (not NGspice)
            voltage[0]=self.i_cmpst             
                        
        return 0

    ##############################################

    #~ def get_isrc_data(self, current, time, node, ngspice_id):  # I could not get current probing to work
        #~ self._logger.debug('ngspice_id-{} get_isrc_data @{} node {}'.format(ngspice_id, time, node))
        #~ current[0] = 1.
        #~ return 0
        
    ############################################## 
    # NGspice data sent to Python

    def send_data(self, actual_vector_values, number_of_vectors, ngspice_id):
        self.angle_out = actual_vector_values['angle'].real
        self.h1_out = round(actual_vector_values['h1'].real) # Need rounding since this is a floating point analog voltage
        self.h2_out = round(actual_vector_values['h2'].real)        
        self.h3_out = round(actual_vector_values['h3'].real)
        self.i_sns_a_out = actual_vector_values['i_sns_a'].real        
        self.i_sns_b_out = actual_vector_values['i_sns_b'].real        
        self.i_sns_c_out = actual_vector_values['i_sns_c'].real
        self.p_28v_out = actual_vector_values['p_28v'].real        
        self.w_out = actual_vector_values['w'].real        
        self.target_out = actual_vector_values['target'].real 
        self.clk_out = actual_vector_values['clk'].real
        #~ self.idt_in_1 = actual_vector_values['x1.xx1.xx5.xx2.xx7.idt_in'].real  # example of probing a net in the hierarchy
        return 0    

####################################################################################################

# libraries_path = './'
# libraries_path = 'C:\Python\Wood_PYspice\libraries'
libraries_path = find_libraries()
spice_library = SpiceLibrary(libraries_path)
####################################################################################################

circuit = Circuit('top_pyspice_circuit') # An arbitrary name for the circuit; this is only referenced in the terminal for error messages
# analog stimulus that goes nowhere below; just used to probe Python "net" inside digital controller
circuit.V('i_limit', 'i_limit_net', circuit.gnd, 'dc 0 external') 
circuit.V('drv_dir', 'drv_dir_net', circuit.gnd, 'dc 0 external')
circuit.V('i_pol', 'i_pol_net', circuit.gnd, 'dc 0 external')
circuit.V('i_cmpst', 'i_cmpst_net', circuit.gnd, 'dc 0 external')
# Real analog stimuli below:
circuit.V('a', 'a', circuit.gnd, 'dc 0 external')
circuit.V('b', 'b', circuit.gnd, 'dc 0 external')
circuit.V('c', 'c', circuit.gnd, 'dc 0 external')

# Note that PySpice will parse ALL *.lib in the directory, even if they are not included, so keep extra .libs out
# the directory where the .lib files are called from is specified in 'libraries_path' (line 327 above)
circuit.include(spice_library['ngspice_top'])
# Top level circuit annotated as "x1"
circuit.X(1,'ngspice_top', 'a', 'b', 'c', 'angle', 'h1', 'h2', 'h3', 'i_sns_a', 'i_sns_b', 'i_sns_c', 'p_28v', 'target', 'w', 'clk') 

end_time = 0.5 # Simulation stop time; interesting current overshoot at 3.31s
g_ovr_i = 500 # Gain of current-limit loop.1992 is max gain for 60deg PM; used 500 for nice transient response
g_angle = -25 # Gain for positional loop
gear_rat = 793.08 # Gear ratio from motor shaft to controlled tail surface
deg_range = 15 # Range of motion (+/-) of tail surface from center position 
i_lim = 0.64516 # Current limit normalized to 31A
pz_cap = 10.0E-6 # Pole-Zero compensition of current-limit loop; C value
pz_rbig = 10.0E3 # Pole-Zero compensition of current-limit loop; R value to form pole with C
pz_rsmall = 54.0 # Pole-Zero compensition of current-limit loop; R value to from zero with C; place zero at electrical tau of motor (L/R)
vdd_hall = 5.0 # VDD for Hall effect sensors for scaling signal

ngspice_shared = MyNgSpiceShared(g_ovr_i= g_ovr_i, g_angle=g_angle, gear_rat=gear_rat, 
deg_range=deg_range, i_lim=i_lim, pz_cap=pz_cap, pz_rbig=pz_rbig, pz_rsmall=pz_rsmall, vdd_hall=vdd_hall, send_data=True)

simulator = circuit.simulator(temperature=25, nominal_temperature=25, simulator='ngspice-shared', ngspice_shared=ngspice_shared)
#~ simulator.options(reltol=1000E-6, chgtol=1E-14, abstol=1E-12, gmin=1E-12, vntol=1E-6, rseries=0, trtol=7, rshunt=1E12, xmu=0.5, maxord=2, itl3=4, itl4=10, itl5=5000) #NgSpice defaults (similar to LTspice)
simulator.options(reltol=1E-3, chgtol=1E-13, abstol=1E-11, gmin=1E-12, vntol=1E-5, rseries=10E-6, trtol=7, rshunt=1.0E12, xmu=0.5, maxord=6, itl3=8, itl4=20, itl5=0)
simulator.initial_condition(angle=0, w=0, p_28v=28, clk=0, target=2.5)
#~ simulator.initial_condition['x1.xx1.p_28v_1']=28 # example of setting .ic for inner node??
#~ simulator.save(V(h1)) #not implemented yet??
# strangely, constraining max_time can have opposite the intended effect (in addition to slowing down the sim)
analysis = simulator.transient(step_time=5E-6, end_time=end_time, max_time=10000E-6, use_initial_condition=True)
####################################################################################################
sim_end_time = datetime.datetime.now()
print('Simulation End Time =', sim_end_time)
elapsed = sim_end_time - sim_start_time
print('Total Simulation Time =', elapsed)


#####################################################################################################
#
# PLOTTING RESULTS:

NUMBER_PLOTS = '5'

figure1 = plt.figure(1, (20, 11.1))
plot1 = plt.subplot(int(NUMBER_PLOTS+'11'))
#~ plt.title('BLDC Simulation')
#~ plt.xlabel('Time [s]')
plt.ylabel('Voltage [V]')
plt.grid()
#~ plot(analysis.a)
#~ plot(analysis.b)
#~ plot(analysis.c)
#~ plot(analysis.angle+2)
plot(analysis.h1+u_V(10))
plot(analysis.h2+u_V(20))
plot(analysis.h3+u_V(30))
#~ plot(analysis['x1.xx1.xx5.xx2.xx7.idt_in'])#working example for plotting signal buried in hierarchy
#~ plot(analysis.i_sns_a)
#~ plot(analysis.i_sns_b)
#~ plot(analysis.i_sns_c)
plot(analysis.p_28v)
#~ plot(analysis.w)
#~ print(analysis.w)
#~ plot(analysis.target)
plt.legend(('h1','h2','h3', 'p_28v'), loc=(.05,.1))
#~ plt.legend(('a', 'b','c', 'angle','h1','h2','h3', 'i_sns_a', 'i_sns_b', 'i_sns_c', 'p_28v', 'w', 'target'), loc=(.05,.1))
#~ plt.ylim(float(-0.1), float(36)) # plot will autoscale by default
plt.setp(plot1.get_xticklabels(), visible=False)

plot2 = plt.subplot(int(NUMBER_PLOTS+'12'), sharex=plot1)
plt.ylabel('Voltage [V]')
plt.grid()
#~ plot(analysis.a)
#~ plot(analysis.b)
#~ plot(analysis.c)
plot(analysis['x1.xx1.phase_a'])
plot(analysis['x1.xx1.phase_b'])
plot(analysis['x1.xx1.phase_c'])
plt.legend(('phase_a', 'phase_b', 'phase_c'), loc=(.05,.1))
#~ plt.ylim(float(-1.0), float(25))
plt.setp(plot2.get_xticklabels(), visible=False)

plot3 = plt.subplot(int(NUMBER_PLOTS+'13'), sharex=plot1)
plt.ylabel('Voltage [V]')
plt.grid()
plot(analysis.w/2/3.14159*60)
plt.legend(('rpm','clk'), loc=(.05,.1))
#~ plt.ylim(float(-11E3), float(11E3))
plt.setp(plot3.get_xticklabels(), visible=False)

plot4 = plt.subplot(int(NUMBER_PLOTS+'14'), sharex=plot1)
plt.ylabel('Voltage [V]')
plt.grid()
plot(analysis.angle*2.5/(793.08*15/360*2*3.14159) * 6)
plot(analysis.target*6-u_V(2.5)*6)
plot(analysis['x1.xx1.t_in'])
plot(analysis.i_limit_net)
plot(analysis.drv_dir_net)
plot(analysis.i_pol_net)
plt.legend(('actual_angle', 'target_angle','Torque_IN', 'I_limit', 'drv_dir','i_pol'), loc=(.05,.1))
plt.ylim(-1.1, 1.1)
plt.setp(plot4.get_xticklabels(), visible=False)

plot5 = plt.subplot(int(NUMBER_PLOTS+'15'), sharex=plot1)
plt.ylabel('Current [A]')
plt.grid()
plot((analysis.i_sns_a-u_V(2.5))*31/2.5)
plot((analysis.i_sns_b-u_V(2.5))*31/2.5)
plot((analysis.i_sns_c-u_V(2.5))*31/2.5)
plot((analysis.i_cmpst_net)*31)
plt.legend(('I_sense_A', 'I_sense_B', 'I_sense_C', 'I_Cmpst'), loc=(.05,.1))
#~ plt.ylim(float(-35.0), float(35.0))
#~ plt.setp(plot5.get_xticklabels(), visible=False) #last subplot needs x-axis ticks visible

plt.subplots_adjust(left=0.05, right=0.99, bottom=0.02, top=0.99, wspace=0, hspace=0.05)
#~ plt.tight_layout() #better results with above line
#~ figManager = plt.get_current_fig_manager() #attempt to maximize plot window; not working for me
#~ figManager.window.showMaximized()

with open('myplot.pkl','wb') as fid: #saves mpylot.pkl for future loading by pickle
    pickle.dump(plot1, fid) # seems to be a bug in pickle.load, since xshared is not working properly (zooming all plots to have the same span of time is tedious)
plt.show()

